options
{
	MULTI=true;
	OUTPUT_LANGUAGE="c++";
	STATIC=false;
  	NODE_SCOPE_HOOK=true;
	VISITOR=true;
	NAMESPACE="Pomme";
  	NODE_CLASS="PommeNode";
}

PARSER_BEGIN(PommeLexer)

	void jjtreeOpenNodeScope(PommeNode *n)
	{
	if (n == nullptr) return;
	n->setLineNumber( getToken(1)->beginLine );
	n->setLineColumn( getToken(1)->beginColumn );
	}

	void jjtreeCloseNodeScope(PommeNode *n)
	{
	}

PARSER_END(PommeLexer)

SKIP :
{
	" "
	| "\r"
	| "\t"
	| "\n"
	| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
	| <"/*"(~["/"])*  "*""/" >
}

TOKEN: 
{ 
	<ASSIGNEMENT : "=">  
	| <ADD : "+">  
	| <ADDEQ : "+=">
	| <MINUS : "-"> 
	| <MINUSEQ : "-=">
	| <MULT : "*"> 
	| <MULTEQ : "*=">
	| <DIV : "/"> 
	| <DIVEQ : "/=">
	| <OREQ : "|=">
	| <ANDEQ : "&=">
	| <SHIFTL : "<<">
	| <SHIFTLEQ : "<<=">
	| <SHIFTR : ">>">
	| <SHIFTREQ : ">>=">
	| <INCR : "++"> 
	| <DECR : "--"> 
	| <MODULO : "%">
}

TOKEN:
{
	<CLASS : "class">
	| <ENUM : "enum"> 
	| <TYPEDEF : "typedef">
	| <IF : "if"> 
	| <ELSE : "else"> 
	| <WHILE : "while"> 
	| <PRINT : "print"> 
	| <RETURN : "return"> 
	| <BREAK : "break">
	| <SWITCH : "switch">
	| <CASE : "case">
	| <DEFAULTCASE : "default">
}

TOKEN:
{
	<PARENTL : "("> 
	| <PARENTR : ")"> 
	| <BRACEL : "{"> 
	| <BRACER : "}">
	| <BRACKETL : "["> 
	| <BRACKETR : "]"> 
	| <COLON : ":">
	| <SEMICOLON : ";"> 
	| <COMMA : ","> 
	| <POINT : ".">
	| <EXCLAMATION : "!">
	| <TILDE : "~">
}

TOKEN:
{
	<EQ : "=="> 
	| <NEQ : "!=">
	| <GT : ">"> 
	| <GET : ">=">
	| <LT : "<"> 
	| <LET : "<=">
	| <OR : "||"> 
	| <AND : "&&">
}

TOKEN:
{
	<VOID: "void">
	| <CONST: "const">
	| <NATIVE: "native">
	| <EXTENDS: "extends">
	| <MODDED: "modded">
	| <STATIC: "static">
	| <PUBLIC: "public">
	| <PRIVATE: "private">
	| <PROTECTED: "protected">
	| <OVERRIDE: "override">
	| <TRUE : "true">
	| <FALSE : "false">
	| <NULLEXP : "null">
	| <NEWEXP : "new">
	| <DELETEEXP : "delete">
	| <INT : (["0"-"9"])+>
	| <IDENTIFIEROPERATOR : ("operator")(<ADDEQ>|<MINUSEQ>|<MULTEQ>|<DIVEQ>|<OREQ>|<ANDEQ>|<SHIFTREQ>|<SHIFTLEQ>|<INCR>|<DECR>|<GT>|<LT>|<GET>|<LET>|<EQ>|<NEQ>|<ADD>|<MINUS>|<MULT>|<DIV>|<MODULO>|"bool")>
	| <IDENTIFIER : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])*>
	| <STRING : "\""(~["\n","\r"])*"\"">
	| <FLOAT : (["0"-"9"])*["."](["0"-"9"])+>
}

SimpleNode* input() #PommeInput:
{}
{
	scopes() { return jjtThis; }
}

void ident() #PommeIdent:
{Token *t;}
{
   t = <IDENTIFIER> { jjtThis->m_Identifier = t->image; }
}

void identOp() #PommeIdentOp:
{Token *t;}
{
	t = <IDENTIFIEROPERATOR> { jjtThis->m_Identifier = t->image; }
}

void pommeInt() #PommeInt:
{Token *t;}
{
   t= <INT> {  jjtThis->m_Value = std::stoull(t->image); }
}

void pommeFloat() #PommeFloat:
{Token *t;}
{
   t= <FLOAT> { jjtThis->m_Value = std::stod(t->image);  }
}

void pommeString() #PommeString:
{Token *t;}
{
   t= <STRING> { jjtThis->m_Value = t->image;  }
}

void scopes() #void :
{}
{
	scope() <SEMICOLON> scopes() #PommeScopes(2)
	| {} #PommeScinil
}

void scope() #void :
{}
{
	LOOKAHEAD(2) classes()
	| globalFunction()
	| enumerate()
	| <TYPEDEF> ident() ident() #PommeTypeDef(2)
}

void classes() #void :
{}
{
	<CLASS> ident() ( 	<BRACEL> decls() <BRACER> #PommeClass(2)
						| <EXTENDS> ident() <BRACEL> decls() <BRACER> #PommeClassChild(3)
					)
	| <MODDED> <CLASS> ident() <BRACEL> decls() <BRACER> #PommeModdedClass(2)
}

void decls() #void :
{}
{
	decl() <SEMICOLON> decls() #PommeDecls(2)
	| {} #PommeDnil
}

void decl() #void :
{}
{ 
	<TILDE> ident() <PARENTL> <PARENTR> <BRACEL> instrs() <BRACER> #PommeDestructor(2)
	| <NATIVE> pommeStatic() visibility() typemeth() identmeth() <PARENTL> headers() <PARENTR> #PommeMethodeNative(5)
	| LOOKAHEAD(ident() <PARENTL>) ident() <PARENTL> headers() <PARENTR> <BRACEL> instrs() <BRACER> #PommeConstructor(3)
	| identfuncs() (
		LOOKAHEAD(<VOID> | methode()) methode()
		| var() #PommeVarDecls(2)
	)
}

void methode() #void :
{}
{
	typemeth() identmeth() <PARENTL> headers() <PARENTR> <BRACEL> instrs() <BRACER> #PommeMethode(5)
}

void identfuncs() #void :
{}
{
	pommeStatic() visibility() pommeOverride() #PommeIdentFuncs(3)
}

void pommeStatic() #void :
{}
{
	<STATIC> #PommeStatic
	| {} #PommeSnil
}

void visibility() #void :
{}
{
	<PUBLIC> #PommePublic
	| <PRIVATE> #PommePrivate
	| <PROTECTED> #PommeProtected
	| {} #PommeVinil
}

void pommeOverride() #void :
{}
{
	<OVERRIDE> #PommeOverride
	| {} #PommeOnil
}

void enumerate() #void :
{}
{
	<ENUM> ident() 	( 	<BRACEL> declenums() <BRACER> #PommeEnum(2)
						| <EXTENDS> ident() <BRACEL> declenums() <BRACER> #PommeExtendsEnum(3)
					)
	| <MODDED> <ENUM> ident() <BRACEL> declenums() <BRACER> #PommeModdedEnum(2)
}

void declenums() #void :
{}
{
	declenum() 	( 	<COMMA> declenums() #PommeDeclEnums(2)
					| {} 
				)
	| {} #PommeEnnil
}

void declenum() #void :
{}
{
	ident() ( 	<ASSIGNEMENT> pommeInt() #PommeEnumAssign(2)
				| {} #PommeEnumDefault(1)
			)
}

void globalFunction() #void :
{}
{
	typemeth() ident() <PARENTL> headers() <PARENTR> <BRACEL> instrs() <BRACER> #PommeGlobalFunction(4)
	| <NATIVE> typemeth() ident() <PARENTL> headers() <PARENTR> #PommeGlobalFunctionNative(3)
}

void instrs() #void :
{}
{
	instr() <SEMICOLON> instrs() #PommeInstrs(2)
	| {} #PommeInil
}

void instr() #void :
{}
{
	LOOKAHEAD(2) var()
	| <INCR> listaccess() #PommeIncrPre(1)
	| <DECR> listaccess() #PommeDecrPre(1)
	| <DELETEEXP> listaccess() #PommeDelete(1)
	| <RETURN> exp() #PommeReturn(1)
	| <WHILE> <PARENTL> exp() <PARENTR> <BRACEL> instrs() <BRACER> #PommeWhile(2)
	| <BREAK> #PommeBreak
	| <IF> <PARENTL> exp() <PARENTR> <BRACEL> instrs() <BRACER> pommeElse() #PommeIf(3)
	| <PRINT> <PARENTL> exp() <PARENTR> #PommePrint(1)
	| <SWITCH> <PARENTL> exp() <PARENTR> <BRACEL> listcases() <BRACER> #PommeSwitch(2)
	| listaccess() ( <ASSIGNEMENT> exp() #PommeAssign(2) 
					| <ADDEQ> exp() #PommeAddEq(2) 
					| <MINUSEQ> exp() #PommeMinusEq(2) 
					| <DIVEQ> exp() #PommeDivEq(2) 
					| <MULTEQ> exp() #PommeMultEq(2) 
					| <OREQ> exp() #PommeOrEq(2) 
					| <ANDEQ> exp() #PommeAndEq(2) 
					| <SHIFTLEQ> exp() #PommeShiftLEq(2)
					| <SHIFTREQ> exp() #PommeShiftREq(2)
					| <INCR> #PommeIncrPost(1)
					| <DECR> #PommeDecrPost(1)
					| {}
				)
}

void listcases() #void :
{}
{
	pommecase() listcases() #PommeCases(2)
	| <DEFAULTCASE> <COLON> <BRACEL> instrs() <BRACER> #PommeDefault(1)
	| {} #PommeSwinil
}

void pommecase() #void :
{}
{
	<CASE> exp() <COLON> <BRACEL> instrs() <BRACER> #PommeCase(2)
}

void pommeElse() #void :
{}
{
  	<ELSE> <BRACEL> instrs() <BRACER>
	| {} #PommeInil
}

void listexp() #void :
{}
{
  	exp() listexpP() #PommeListExp(2)
	| {} #PommeExnil
}

void listexpP() #void :
{}
{
  	<COMMA> exp() listexpP() #PommeListExp(2)
	| {} #PommeExnil
}

void var() #void :
{}
{
	type() ident() vexp() #PommeVariable(3)
	| <CONST> type() ident() vexp() #PommeConstant(3)
}

void vexp() #void :
{}
{
	<ASSIGNEMENT> exp()
	| {} #PommeOmega
}

void headers() #void :
{}
{
   	header() headersP()	#PommeHeaders(2)
 	| {} #PommeEnil
}

void headersP() #void :
{}
{
  	<COMMA> header() headersP()	#PommeHeaders(2)
 	| {} #PommeEnil
}


void header() #void :
{}
{
  	<CONST> type() ident() #PommeConstHeader(2)
	|  type() ident() #PommeHeader(2)
}

void typemeth() #void :
{}
{
	<VOID> #PommeVoidType
  	| type()
}

void identmeth() #void :
{}
{
	ident()
	| identOp()
}

void type() #void:
{}
{
	ident()
}

void exp() #void :
{}
{
 	exp1() expP()
}

void expP() #void :
{}
{
  	<AND> exp1() expP() #PommeAnd(2)
  	| <OR> exp1() expP() #PommeOr(2)
  	| {} 
}

void exp1() #void :
{}
{
	exp2() exp1P()
}

void exp1P() #void :
{}
{
  	<EQ> exp2() exp1P() #PommeEQ(2)
	| <NEQ> exp2() exp1P() #PommeNEQ(2)
	| <GT> exp2() exp1P() #PommeGT(2)
	| <GET> exp2() exp1P() #PommeGET(2)
	| <LT> exp2() exp1P() #PommeLT(2)
	| <LET> exp2() exp1P() #PommeLET(2)
  	| {} 
}

void exp2() #void :
{}
{
	terme() exp2P()
}

void exp2P() #void :
{}
{
  	<ADD> terme() exp2P() #PommeAdd(2)
	| <MINUS> terme() exp2P() #PommeMinus(2)
	| <SHIFTR> terme() exp2P() #PommeShiftR(2)
	| <SHIFTL> terme() exp2P() #PommeShiftL(2)
  	| {} 
}

void terme() #void :
{}
{
	fact2() termeP()
}

void termeP() #void :
{}
{
  	<MULT> fact2() termeP() #PommeMult(2)
	| <DIV> fact2() termeP() #PommeDiv(2)
	| <MODULO> fact2() termeP() #PommeModulo(2)
  	| {} 
}

void fact2() #void :
{}
{
	LOOKAHEAD(3) fact()
	| <PARENTL> exp() <PARENTR>
	| <MINUS> fact2() #PommeUnary(1)
	| <EXCLAMATION> fact2() #PommeNot(1)
	| <TILDE> fact2() #PommeTilde(1)
}

void fact() #void :
{}
{
	<NEWEXP> ident() <PARENTL> listexp() <PARENTR> #PommeNew(2) 
	| listaccess()
	| <TRUE> #PommeTrue
	| <FALSE> #PommeFalse
	| number()
	| pommeString()
	| <NULLEXP> #PommeNull
}

void listaccess() #void :
{}
{
  	access() ( 	<POINT> access() listaccessP() #PommeListAccess(3)
	  			| <BRACKETL> exp() <BRACKETR> listaccessP() #PommeAccessTab(3)
				| {}
	  		)
}

void listaccessP() #void :
{}
{
	(
		<POINT> ( 
				access() (	
							<POINT> access() listaccessP() #PommeListAccessP(3)
							| <BRACKETL> exp() <BRACKETR> listaccessP() #PommeAccessTab(3)
							| {}
						)
			)
		| {} #PommeAcnil
	)
}

void access() #void :
{}
{
	LOOKAHEAD(2) identmeth() <PARENTL> listexp() <PARENTR> #PommeAccessMethode(2)
	| ident() 
}

void number() #void :
{}
{
	pommeInt()
	| pommeFloat()
}