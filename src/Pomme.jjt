options
{
	MULTI=true;
	OUTPUT_LANGUAGE="c++";
	STATIC=false;
  	NODE_SCOPE_HOOK=true;
	VISITOR=true;
	NAMESPACE="Pomme";
  	NODE_CLASS="PommeNode";
}

PARSER_BEGIN(PommeLexer)

void jjtreeOpenNodeScope(PommeNode *n)
{
  if (n == nullptr) return;
  n->setLineNumber( getToken(1)->beginLine );
  n->setLineColumn( getToken(1)->beginColumn );
}

void jjtreeCloseNodeScope(PommeNode *n)
{
}

PARSER_END(PommeLexer)

SKIP :
{
	" "
	| "\r"
	| "\t"
	| "\n"
	| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
	| <"/*"(~["/"])*  "*""/" >
}

TOKEN: 
{ 
	<ASSIGNEMENT : "=">  
	| <ADD : "+">  
	| <ADDEQ : "+=">
	| <MINUS : "-"> 
	| <MINUSEQ : "-=">
	| <MULT : "*"> 
	| <MULTEQ : "*=">
	| <DIV : "/"> 
	| <DIVEQ : "/=">
	| <OREQ : "|=">
	| <ANDEQ : "&=">
	| <SHIFTL : "<<">
	| <SHIFTLEQ : "<<=">
	| <SHIFTR : ">>">
	| <SHIFTREQ : ">>=">
	| <INCR : "++"> 
	| <DECR : "--"> 
	| <MODULO : "%">
}

TOKEN:
{
	<CLASS : "class">
	| <ENUM : "enum"> 
	| <IF : "if"> 
	| <ELSE : "else"> 
	| <WHILE : "while"> 
	| <PRINT : "print"> 
	| <RETURN : "return"> 
	| <BREAK : "break">
	| <SWITCH : "switch">
	| <CASE : "case">
	| <DEFAULTCASE : "default">
}

TOKEN:
{
	<PARENTL : "("> 
	| <PARENTR : ")"> 
	| <BRACEL : "{"> 
	| <BRACER : "}"> 
	| <BRACKETL : "["> 
	| <BRACKETR : "]"> 
	| <COLON : ":">
	| <SEMICOLON : ";"> 
	| <COMMA : ","> 
	| <POINT : ".">
	| <EXCLAMATION : "!">
	| <TILDE : "~">
}

TOKEN:
{
	<EQ : "=="> 
	| <NEQ : "!=">
	| <GT : ">"> 
	| <GET : ">=">
	| <LT : "<"> 
	| <LET : "<=">
	| <OR : "||"> 
	| <AND : "&&">
}

TOKEN:
{
	<VOID: "void">
	| <CONST: "const">
	| <NATIVE: "native">
	| <EXTENDS: "extends">
	| <MODDED: "modded">
	| <STATIC: "static">
	| <PUBLIC: "public">
	| <PRIVATE: "private">
	| <PROTECTED: "protected">
	| <OVERRIDE: "override">
	| <TRUE : "true">
	| <FALSE : "false">
	| <NULLEXP : "null">
	| <NEWEXP : "new">
	| <INT : (["0"-"9"])+>
	| <IDENTIFIER : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*>
	| <IDENTIFIEROPERATOR : ("operator")("\\+="|"-="|"\\*="|"\\/="|"\\|="|"&="|">>="|"<<="|"\\+\\+"|"--"|">"|"<"|">="|"<="|"=="|"!="|"\\+"|"-"|"\\*"|"\\/"|"%"|"bool")>
	| <STRING : "\""(~["\n","\r"])*"\"">
	| <FLOAT : (["0"-"9"])*["."](["0"-"9"])+>
}

SimpleNode* input() : {}
{
	scopes() { return jjtThis; }
}

void ident() #ident:
{Token *t;}
{
   t = <IDENTIFIER> { }
}

void identOp() #identOp:
{Token *t;}
{
	t = <IDENTIFIEROPERATOR> { }
}

void pommeInt() #pommeInt:
{Token *t;}
{
   t= <INT> {  }
}

void pommeFloat() #pommeFloat:
{Token *t;}
{
   t= <FLOAT> {  }
}

void pommeString() #pommeString:
{Token *t;}
{
   t= <STRING> {  }
}

void scopes() #void :
{}
{
	scope() <SEMICOLON> scopes() #scopes(2)
	| {} #scinil
}

void scope() #void :
{}
{
	LOOKAHEAD(2) classes()
	| globalFunction()
	| enumerate()
}

void classes() #void :
{}
{
	LOOKAHEAD(3) <CLASS> ident() <BRACEL> decls() <BRACER> #defaultClass(2)
	| <CLASS> ident() <EXTENDS> ident() <BRACEL> decls() <BRACER> #classChild(3)
	| <MODDED> <CLASS> ident() <BRACEL> decls() <BRACER> #moddedClass(2)
}

void decls() #void :
{}
{
	decl() <SEMICOLON> decls() #decls(2)
	| {} #dnil
}

void decl() #void :
{}
{
	LOOKAHEAD(3) var()
	| methode()
}

void methode() #void :
{}
{
	identfuncs() typemeth() identmeth() <PARENTL> entetes() <PARENTR> <BRACEL> instrs() <BRACER> #methode(5)
	| <NATIVE> pommeStatic() visibility() typemeth() identmeth() <PARENTL> entetes() <PARENTR> #methodeNative(5)
}

void identfuncs() #void :
{}
{
	pommeStatic() visibility() pommeOverride() #identFuncs(3)
}

void pommeStatic() #void :
{}
{
	<STATIC> #staticChild
	| {} #snil
}

void visibility() #void :
{}
{
	<PUBLIC> #publicChild
	| <PRIVATE> #privateChild
	| <PROTECTED> #protectedChild
	| {} #vinil
}

void pommeOverride() #void :
{}
{
	<OVERRIDE> #overrideChild
	| {} #onil
}

void enumerate() #void :
{}
{
	LOOKAHEAD(3) <ENUM> ident() <BRACEL> declenums() <BRACER> #enumerate(2)
	| <ENUM> ident() <EXTENDS> ident() <BRACEL> declenums() <BRACER> #extendsEnumerate(3)
	| <MODDED> <ENUM> ident() <BRACEL> declenums() <BRACER> #moddedEnumerate(2)
}

void declenums() #void :
{}
{
	LOOKAHEAD(4) declenum() <COMMA> declenums()	#declenums(2)
	| declenum()
	| {} #ennil
}

void declenum() #void :
{}
{
	LOOKAHEAD(2) ident() <ASSIGNEMENT> pommeInt() #enumassign(2)
	| ident() #enumdefault(1)
}

void globalFunction() #void :
{}
{
	typemeth() ident() <PARENTL> entetes() <PARENTR> <BRACEL> instrs() <BRACER> #globalFunction(4)
	| <NATIVE> typemeth() ident() <PARENTL> entetes() <PARENTR> #globalFunctionNative(3)
}

void instrs() #void :
{}
{
	instr() <SEMICOLON> instrs() #instrs(2)
	| {}	#inil
}

void instr() #void :
{}
{
	LOOKAHEAD(2) ident() <PARENTL> listexp() <PARENTR> #callI(2)
	| LOOKAHEAD(5) ident() <POINT> ident() <PARENTL> listexp() <PARENTR> #callIClass(3)
	| LOOKAHEAD(5) ident1() <ASSIGNEMENT> exp() #assignement(2)
	| LOOKAHEAD(5) ident1() <ADDEQ> exp() #addeq(2)
	| LOOKAHEAD(5) ident1() <MINUSEQ> exp() #minuseq(2)
	| LOOKAHEAD(5) ident1() <DIVEQ> exp() #diveq(2)
	| LOOKAHEAD(5) ident1() <MULTEQ> exp() #multeq(2)
	| LOOKAHEAD(5) ident1() <OREQ> exp() #oreq(2)
	| LOOKAHEAD(5) ident1() <ANDEQ> exp() #andeq(2)
	| LOOKAHEAD(5) ident1() <SHIFTLEQ> exp() #shiftleq(2)
	| LOOKAHEAD(5) ident1() <SHIFTREQ> exp() #shiftreq(2)
	| LOOKAHEAD(5) ident1() <INCR> #incrementPost(1)
	| LOOKAHEAD(5) ident1() <DECR> #decrementPost(1)
	| <INCR> ident1() #incrementPre(1)
	| <DECR> ident1() #decrementPre(1)
	| <RETURN> exp() #pommeReturn(1)
	| <WHILE> <PARENTL> exp() <PARENTR> <BRACEL> instrs() <BRACER> #pommeWhile(2)
	| <BREAK> #pommeBreak
	| <IF> <PARENTL> exp() <PARENTR> <BRACEL> instrs() <BRACER> pommeElse() #pommeIf(3)
	| <PRINT> <PARENTL> exp() <PARENTR> #pommePrint(1)
	| <SWITCH> <PARENTL> exp() <PARENTR> <BRACEL> listcases() <BRACER> #pommeSwitch(2)
	| var()
}

void listcases() #void :
{}
{
	<CASE> exp() <COLON> <BRACEL> instrs() <BRACER> listcases() #pommeCases(3)
	| <DEFAULTCASE> <COLON> <BRACEL> instrs() <BRACER> #pommeDefault(1)
	| {} #swinil
}

void pommeElse() #void :
{}
{
  	<ELSE> <BRACEL> instrs() <BRACER>
	| {} #inil
}

void listexp() #void :
{}
{
  	exp() listexpP() #listexp(2)
	| {} #exnil
}

void listexpP() #void :
{}
{
  	<COMMA> exp() listexpP() #listexp(2)
	| {} #exnil
}

void var() #void :
{}
{
	type() ident() vexp() #var(3)
	| <CONST> type() ident() vexp() #constant(3)
}

void vexp() #void :
{}
{
	<ASSIGNEMENT> exp()
	| <BRACKETL> exp() <BRACKETR> #array(1)
	| {}	#omega
}

void entetes() #void :
{}
{
   	entete() entetes2()	#entetes(2)
 	| {}	#enil
}

void entetes2() #void :
{}
{
  	<COMMA> entete() entetes2()	#entetes(2)
 	| {}	#enil
}


void entete() #void :
{}
{
  	type() ident()	#entete(2)
}

void typemeth() #void :
{}
{
	<VOID> #voidType
  	| type()
}

void identmeth() #void :
{}
{
	ident()
	| identOp()
	| <TILDE> ident() #identDestructor(1)
}

void type() #void:
{}
{
	ident()
}

void exp() #void :
{}
{
 	exp1() expP()
}

void expP() #void :
{}
{
  	<AND> exp1() expP() #pommeAnd(2)
  	| <OR> exp1() expP() #pommeOr(2)
  	| {} 
}

void exp1() #void :
{}
{
	exp2() exp1P()
}

void exp1P() #void :
{}
{
  	<EQ> exp2() exp1P() #pommeEQ(2)
	| <NEQ> exp2() exp1P() #pommeNEQ(2)
	| <GT> exp2() exp1P() #pommeGT(2)
	| <GET> exp2() exp1P() #pommeGET(2)
	| <LT> exp2() exp1P() #pommeLT(2)
	| <LET> exp2() exp1P() #pommeLET(2)
  	| {} 
}

void exp2() #void :
{}
{
	terme() exp2P()
}

void exp2P() #void :
{}
{
  	<ADD> terme() exp2P() #pommeAdd(2)
	| <MINUS> terme() exp2P() #pommeMinus(2)
	| <SHIFTR> terme() exp2P() #pommeShiftR(2)
	| <SHIFTL> terme() exp2P() #pommeShiftL(2)
  	| {} 
}

void terme() #void :
{}
{
	fact2() termeP()
}

void termeP() #void :
{}
{
  	<MULT> fact2() termeP() #pommeMult(2)
	| <DIV> fact2() termeP() #pommeDiv(2)
	| <MODULO> fact2() termeP() #pommeModulo(2)
  	| {} 
}

void fact2() #void :
{}
{
	fact()
	| <PARENTL> exp() <PARENTR>
	| <MINUS> fact2() #pommeUnary(1)
	| <EXCLAMATION> fact2() #pommeNot(1)
	| <TILDE> fact2() #pommeTilde(1)
}

void fact() #void :
{}
{
	LOOKAHEAD(3) ident() <PARENTL> listexp() <PARENTR> #callE(2)
	| LOOKAHEAD(5) ident() <POINT> identmeth() <PARENTL> listexp() <PARENTR> #callEClass(3)
	| <NEWEXP> ident() <PARENTL> listexp() <PARENTR> #pommeNew(2) 
	| ident1()
	| <TRUE> #pommeTrue
	| <FALSE> #pommeFalse
	| number()
	| pommeString()
	| <NULLEXP> #pommeNull
}

void ident1() #void :
{}
{
	LOOKAHEAD(2) ident() <POINT> ident1() #accessMember(2)
	| LOOKAHEAD(2) ident() <BRACKETL> exp() <BRACKETR> #accessTab(2)
	| ident()
}

void number() #void :
{}
{
	pommeInt()
	| pommeFloat()
}