todo:
for(){}

scopes -> 	scope ";" scopes |																scopes($1,$3)
			vide																			scinil

scope -> classes |																			$1
		enumerate |																			$1
		globalFunction																		$1

classes -> 	"class" ident "{" decls "}" |													defaultClass($2 ,$4)
			"class" ident "extends" ident "{" decls "}" |									classChild($2, $4, $6)
			"modded" "class" ident "{" decls "}"											moddedClass($3, $5)

enumerate ->    "enum" ident "{" declenums "}" |											enumerate($2, $4)
				"enum" ident "extends" ident "{" declenums "}" |							extendsEnumerate($2, $4, $6)
				"modded" "enum" ident "{" declenums "}" | 									moddedEnumerate($3, $5)

declenums -> declenum "," declenums |														declenums($1, $3)
			 vide																			ennil

declenum -> ident "=" pommeInt |															enumAssign($1, $3)
			ident																			enumDefault($1)

globalFunction -> 	typemeth ident "(" entêtes ")" "{" instrs "}" |							globalFunction($1, $2, $3, $5, $8)		
					"native" typemeth ident "(" entêtes ")"									globalFunctionNative($2, $3, $5)													

ident -> 	identificateur 																	ident($1)

decls -> 	decl ";" decls | 																decls($1, $3)
			vide 																			dnil

decl -> 	var | 																			$1
			methode 																		$1

var -> 		type ident vexp | 																var($1, $2, $3)
			"const" type ident vexp 														cst($2, $3, $4)

vexp -> 	"=" exp | 																		assignInit($2)
			"[" exp "]" | 																	array($2)
			vide 																			omega

methode -> 	identfuncs typemeth identmeth "("entêtes")" "{" instrs "}" |					methode($1, $2, $3, $5, $8)
			"native" pommeStatic visibility typemeth identmeth "(" entêtes ")"				methodeNative($2, $3, $4, $5, $7)

identfuncs -> 	pommeStatic visibility pommeOverride |										identFuncs($1, $2, $3)

pommeStatic -> 	"static" | 																	staticChild
				vide 																		snil																

visibility -> 	"public" | 																	publicChild
				"private" | 																privateChild
				"protected" |																protectedChild
				vide																		vinil

pommeOverride ->  "override" | 																overrideChild
					vide																	onil

entêtes -> 	entête "," entêtes | 															entêtes($1, $3)
			entête | 																		entêtes($1, enil)
			vide 																			enil

entête -> 	type ident 																		entête($1,$2)

instrs -> 	instr ";" instrs |																instrs($1, $3)
			vide 																			inil

instr -> 	ident1 "=" exp | 																assignement($1, $3)
			ident1 "+=" exp | 																addeq($1,$3)
			ident1 "-=" exp | 																minuseq($1,$3)
			ident1 "/=" exp | 																diveq($1,$3)
			ident1 "*=" exp | 																multeq($1,$3)
			ident1 "|=" exp | 																oreq($1,$3)
			ident1 "&=" exp | 																andeq($1,$3)
			ident1 "<<=" exp | 																shiftleq($1,$3)
			ident1 ">>=" exp | 																shiftreq($1,$3)
			ident1"++" | 																	incrementPost($1)
			"++"ident1 | 																	incrementPre($2)
			ident "(" listexp ")" | 														callI($1,$3)
			ident "." identmeth "(" listexp ")" | 											callIClass($1, $3, $5)
			"return" exp | 																	pommeReturn($2)
			"if" "(" exp ")" "{" instrs "}" [else "{" instrs "}"] | 						pommeIf($3, $6, $8)
			"while" "(" exp ")" "{" instrs "}" |											pommeWhile($3, $6)
			"switch" "(" fact ")" "{" listcases "}" |										pommeSwitch($3, $6)
			"print" "(" ident1 ")" |														print($3)
			"break"	|																		pommeBreak
			var																				$1

listcases -> "case" exp ":" "{" instrs "}" listcases |										pommeCase($2, $5, $7)
			"default" ":" "{" instrs "}" |													pommeDefault($4)
			vide |																			swinil

listexp -> 	exp "," listexp |															 	listexp($1, $3)
			exp | 																			listexp($1)
			vide 																			exnil

exp -> 		"!" exp1 | 																		no($2)
			"-" exp1 | 																		unaryMinus($2)
			exp "&&" exp1 | 																pommeAnd($1, $4)
			exp "||" exp1 | 																pommeOr($1, $4)
			exp1 																			$1

exp1 -> 	exp1 "==" exp2 | 																pommeEQ($1,$3)
			exp1 "!=" exp2 | 																pommeNEQ($1,$3)
			exp1 ">" exp2 | 																pommeGT($1,$3)
			exp1 ">=" exp2 | 																pommeGET($1,$3)
			exp1 "<" exp2 | 																pommeLT($1,$3)
			exp1 "<=" exp2 | 																pommeLET($1,$3)
			exp2 																			$1

exp2 -> 	exp2 "+" terme | 																pommeAdd($1,$3)
			exp2 "-" terme | 																pommeMinus($1,$3)
			exp2 ">>" terme | 																pommeShiftR($1,$3)
			exp2 "<<" terme | 																pommeShiftL($1,$3)
			terme 																			$1

terme -> 	terme "*" fact2 | 																*($1, $3)
			terme "/" fact2 | 																/($1, $3)
			terme "%" fact2 | 																%($1,$3)
			fact2 																			$1
			
fact2 -> 	fact |																			$1
			"("exp")" 																		$2

fact -> 	ident1 | 																		$1
			ident "(" listexp ")" | 														callE($1, $3)
			ident "." identmeth "(" listexp ")" | 											callEClass($1, $3, $5)
			true | 																			pommeTrue
			false | 																		pommeFalse
			number |																		$1
			pommeString																		$1

ident1 -> 	ident | 																		$1
			ident "." ident																	accessMember($1, $3)
			ident"["exp"]" 																	accessTab($1, $3)

typemeth -> void | 																			rien
			type 																			$1

identmeth -> 	ident |																		$1
				identifierOperator															$1

type -> 	ident																			$1

number -> 	pommeInt |																		pommeInt($1)
			pommeFloat																		pommeFloat($2)
			