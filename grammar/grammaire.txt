todo:
for(){}

scopes -> 	scope ";" scopes |																scopes($1,$3)
			vide																			scinil

scope -> classe |																			$1
		enumerate |																				$1
		globalFunction																		$1

classe -> 	"class" ident "{" decls "}" |													class($2 ,$4)
			"class" ident "extends" ident "{" decls "}" |									classChild($2, $4, $6)
			"modded" "class" ident "{" decls "}"											moddedClass($3, $5)

enumerate ->    "enum" ident "{" declenums "}" |											enumerate($2, $4)
				"modded" "enum" ident "{" declenums "}" | 									moddedEnumerate($3, $5)

declenums -> declenum "," declenums |														declenums($1, $3)
			 declenum |																		$1

declenum -> ident "=" nombre |																enumAssign($1, $3)
			ident																			enumDefault($1)

globalFunction -> 	typemeth ident "(" entêtes ")" "{" instrs "}" |							globalFunction($1, $2, $3, $5, $8)		
					"native" typemeth ident "(" entêtes ")"									globalFunctionNative($2, $3, $5)													

ident -> 	identificateur 																	ident($1)

decls -> 	decl ";" decls | 																decls($1, $3)
			vide 																			vnil

decl -> 	var | 																			$1
			methode 																		$1

var -> 		type ident vexp | 																var($1, $2, $3)
			"const" type ident vexp 														cst($2, $3, $4)

vexp -> 	"=" exp | 																		assignInit($2)
			"[" exp "]" | 																	array($2)
			vide 																			omega

methode -> 	identfuncs typemeth ident "("entêtes")" "{" instrs "}"|							methode($1, $2, $3, $5, $8)
			identfuncs typemeth identificateurOperator "("entêtes")" "{" instrs "}"|		methodeOperator($1, $2, $3, $5, $8)
			"native" visibility typemeth ident "("entêtes")"|								methodeNative( $2, $3, $4, $6)
			"native" visibility typemeth identificateurOperator "("entêtes")"				methodeOperatorNative( $2, $3, $4, $6)

identfuncs -> 	static visibility identfunc |												identFuncs($1, $2, $3)
			 	vide

static -> 	"static" | 																		staticChild
			vide 																			snil																

visibility -> 	"public" | 																	publicChild
				"private" | 																privateChild
				"protected" |																protectedChild
				vide																		vinil

identfunc ->  	"override" | 																overrideChild
				vide																		idnil

entêtes -> 	entête "," entêtes | 															entêtes($1, $3)
			entête | 																		entêtes($1, enil)
			vide 																			enil

entête -> 	type ident 																		entête($1,$2)

instrs -> 	instr ";" instrs |																instrs($1, $3)
			vide 																			inil

instr -> 	ident1 "=" exp | 																affectation($1, $3)
			ident1 "+=" exp | 																somme($1,$3)
			ident1 "-=" exp | 																minuseq($1,$3)
			ident1 "/=" exp | 																pluseq($1,$3)
			ident1 "*=" exp | 																multeq($1,$3)
			ident1 "|=" exp | 																oreq($1,$3)
			ident1 "&=" exp | 																andeq($1,$3)
			ident1 "<<=" exp | 																shiftleq($1,$3)
			ident1 ">>=" exp | 																shiftreq($1,$3)
			ident1"++" | 																	incrementPost($1)
			"++"ident1 | 																	incrementPre($2)
			ident"("listexp")" | 															appelI($1,$3)
			ident"."ident"("listexp")" | 													appelIClasse($1, $3)
			"return" exp | 																	retour($2)
			"if" exp "{" instrs "}" [else "{" instrs "}"] | 								si($2, $4, $8)
			"while" exp "{" instrs "}" |													tantque($2, $4)
			"switch" exp "{" listcase "}"|													switch($2, $4)
			"print" "(" exp ")"																print($2)
			"printf" "(" exp ")"															printf($2)
			"break"	|																		break
			var																				$1

listcase -> "case" exp ":" "{" instrs "}" listcase |										case($2, $5, $7)
			"default" ":" "{" instrs "}" |													caseDefault($4)
			vide |																			swinil

listexp -> 	exp "," listexp |															 	listexp($1, $3)
			exp | 																			listexp($1, exnil)
			vide 																			exnil

exp -> 		"!" exp1 | 																		no($2)
			"-" exp1 | 																		unaryMinus($2)
			exp "&&" exp1 | 																et($1, $4)
			exp "||" exp1 | 																ou($1, $4)
			exp1 																			$1

exp1 -> 	exp1 "==" exp2 | 																=($1,$3)
			exp1 "!=" exp2 | 																!=($1,$3)
			exp1 ">" exp2 | 																>($1,$3)
			exp1 "<" exp2 | 																<($1,$3)
			exp1 ">=" exp2 | 																>=($1,$3)
			exp1 "<=" exp2 | 																<=($1,$3)
			exp2 																			$1

exp2 -> 	exp2 "+" terme | 																+($1,$3)
			exp2 "-" terme | 																-($1,$3)
			exp2 ">>" terme | 																>>($1,$3)
			exp2 "<<" terme | 																<<($1,$3)
			terme 																			$1

terme -> 	terme "*" fact | 																*($1, $3)
			terme "/" fact | 																/($1, $3)
			terme "%" fact | 																%($1,$3)
			fact 																			$1

fact -> 	ident1 | 																		$1
			ident"("listexp")" | 															appelE($1, $3)
			ident"."ident"("listexp")" | 													appelEClasse($1, $3)
			true | 																			vrai
			false | 																		faux
			nombre | 																		nbre($1)
			"("exp")" 																		$2

ident1 -> 	ident | 																		$1
			ident"["exp"]" 																	tab($1, $3)

typemeth -> void | 																			rien
			type 																			$1

type -> 	ident																			$1
			